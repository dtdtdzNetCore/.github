# 1. 소개 및 이론
## 이 강좌에서 하는 것

.NET 마이크로서비스 구축의 기술적 측면에 중점을 둡니다.

이론을 진행하면서 다룹니다.

실용적이고 균형 잡힌 접근 방식을 취하지만, 모범 사례를 따릅니다.

완전히 단계별로 진행합니다 – 그래서 길어집니다!

가능한 한 실용적이고 흥미롭게 만듭니다.

마이크로서비스가 어렵다는 점을 인정합니다!

## 이 강좌에서 하지 않는 것

도메인 주도 설계(Domain Driven Design), 바운디드 컨텍스트(Bounded Contexts) 등에 중점을 두지 않습니다.

불필요한 "비즈니스 로직"을 구축하지 않습니다 – 우리의 사용 사례는 단순합니다.

모놀리스를 악마화하거나 유행에 편승하지 않습니다.

모든 것을 다루지 않습니다... 균형을 맞추는 것이 중요했습니다.

## 강좌 요약

| **소개 및 이론**     | **플랫폼 서비스 시작하기**        | **도커 및 쿠버네티스**            | **명령 서비스 시작하기**  | **SQL 서버**               | **다중 리소스 API** | **메시지 버스 / RabbitMQ** | **비동기 메시징** | **gRPC** |
|----------------------|----------------------------------|----------------------------------|---------------------------|----------------------------|----------------------|---------------------------|-------------------|----------|
| - 강좌 개요          | - 개요                           | - 도커 리뷰                      | - 스캐폴딩                | - 퍼시스턴트 볼륨 클레임   | - 명령 서비스에 대한 엔드포인트 검토 | - 솔루션 아키텍처 검토 | - 플랫폼 서비스에 메시지 버스 퍼블리셔 추가 | - gRPC 개요 |
| - 사전 요구사항      | - 스캐폴딩                       | - 플랫폼 서비스 컨테이너화       | - 컨트롤러 및 액션        | - 쿠버네티스 시크릿        | - 데이터 레이어      | - RabbitMQ 개요 | - 이벤트 처리 | - 최종 쿠버네티스 네트워킹 |
| - 도구 및 재료       | - 데이터 레이어                   | - 도커 허브로 푸시               | - 동기 및 비동기 메시징   | - 쿠버네티스에 SQL 서버 배포 | - 컨트롤러 및 액션  | - RabbitMQ를 쿠버네티스에 배포 | - 명령 서비스에 이벤트 리스너 추가 | - 플랫폼 서비스에 gRPC 서버 추가 |
| - 마이크로서비스란?  | - 컨트롤러 및 액션               | - 쿠버네티스 소개                | - HTTP 클라이언트 추가    | - 플랫폼 서비스 재방문    |                      | - 테스트 |                      | - "proto" 파일 생성 |
| - 우리의 서비스      |                                  | - 쿠버네티스 아키텍처            | - 쿠버네티스에 서비스 배포 |                            |                      |         |                      | - 명령 서비스에 gRPC 클라이언트 추가 |
| - 솔루션 아키텍처    |                                  | - 플랫폼 서비스 배포             | - 내부 네트워킹           |                            |                      |         |                      | - 배포 및 테스트 |
| - 서비스 아키텍처    |                                  | - 외부 네트워크 접근             | - API 게이트웨이          |                            |                      |         |                      |          |


## 사전 요구사항
- C#에서 .NET (Core) REST API를 구축한 경험
- 도커 및 관련 개념에 대한 이해
- C#에서의 의존성 주입 (Dependency Injection)
- Async / Await 사용 경험

## 도구
- VS 코드 텍스트 에디터 (무료)
- .NET 5 (무료)
- Docker Desktop (쿠버네티스 실행) (무료)
- Docker Hub 계정 (무료)
- Insomnia 또는 Postman (무료)
- "적당한" 수준의 로컬 하드웨어 (보통 무료가 아님)

## microservice?
- 단일 책임 원칙
- 작음 (2 pizza team, 2 weeks)
- 전체의 일부
- 독립적

### monolithic 사례

대규모 모놀리식 CRM 시스템:

- 수백만 명의 고객에게 서비스를 제공함
- 여러 해에 걸쳐 발전해 옴
- 단일, 독점적인 기술 스택으로 구축됨
- 한 명의 "아웃소싱" 파트너에 의해 관리됨

### 이 시스템은...
- 변경하기 매우 어렵다

    - 변경 주기가 몇 달에 이른다
    - 대규모의 (주로 수작업) 테스트가 필요하다
  
- 확장하기 어렵다

- 종속적이다
    - 기술적 측면에서
    - 지적 재산권 측면에서 (외부 파트너가 권한을 가짐)
### 마이크로서비스의 장점
- 변경 및 배포가 더 쉽다 (작고 분리됨)
- 다양한 기술을 사용하여 구축할 수 있다
- 조직의 소유 및 일치도가 향상된다
- 탄력성: 1개의 서비스가 고장 나도, 다른 서비스는 계속 실행된다
- 확장성: 필요한 서비스만 확장할 수 있다
- 교체하기 쉽게 설계됨 
### 비교
| **마이크로서비스**                | **모놀리스**                        |
|----------------------------------|-------------------------------------|
| 구현하기 어렵다                  | 구현하기 더 간단하다                |
| "분석 마비"를 초래할 수 있다       | CI/CD, 일일 배포, 작은 변경 등을 사용할 수 있다 |
| 강력한 도메인 지식이 필요하다     | 도메인에 익숙해질 수 있다           |
| 분산됨 – 네트워크 장애 발생 가능성 | 2개 또는 3개의 "큰" 서비스가 있을 수 있다  |
| 역설적이게도 항상 무언가에 결합된다| 네트워크에 크게 의존하지 않는다      |

## 이 강좌의 microservice

### "플랫폼" 서비스
- "자산 등록" 기능을 합니다.
- 회사 내 모든 플랫폼/시스템을 추적합니다.
- 인프라 팀에 의해 구축되었습니다.
- 다음 팀에서 사용합니다:
    - 인프라 팀
    - 기술 지원 팀
    - 엔지니어링
    - 회계
    - 조달
### "명령" 서비스
- 주어진 플랫폼에 대한 명령줄 인수의 저장소 역할을 합니다.
- 지원 프로세스의 자동화를 돕습니다.
- 기술 지원 팀에 의해 구축되었습니다.
- 다음 팀에서 사용합니다:
    - 기술 지원 팀
    - 인프라 팀
    - 엔지니어링

### 데이터 공유
플랫폼 서비스와 명령 서비스는 서로 독립적으로 운영되지만, 플랫폼 데이터는 명령 서비스에서 필요할 수 있습니다.

HTTP 통신: 플랫폼 서비스에서 명령 서비스로 HTTP 요청을 통해 데이터를 전송할 수 있습니다.

이벤트 버스 (Event Bus): 더 나은 방법으로, 플랫폼 서비스가 메시지 버스를 통해 이벤트를 발행하면 명령 서비스가 이를 구독하여 데이터를 받을 수 있습니다. 이 방법은 서비스 간의 결합을 최소화합니다.

### 최종 구조
두 서비스는 각자의 데이터베이스를 가지고 있으며, 이벤트 버스(RabbitMQ)를 통해 비동기식으로 데이터를 공유합니다.

gRPC를 사용하여 명령 서비스가 플랫폼 서비스로부터 데이터를 가져올 수 있는 기능도 추가됩니다.

### 플랫폼 서비스의 어플리케이션 아키텍처
- **모델**: 내부 데이터 표현으로 사용됩니다. 예를 들어, `Platform` 모델 클래스는 플랫폼 서비스의 데이터 구조를 정의합니다.
- **DB 컨텍스트**: `AppDbContext` 클래스는 Entity Framework를 사용하여 데이터베이스와 상호작용합니다. DB 컨텍스트는 모델을 데이터베이스에 매핑하고 데이터베이스 작업을 수행하는 데 사용됩니다.
- **DTO (Data Transfer Objects)**: DTO는 외부 클라이언트와의 데이터 교환을 위한 객체로, 모델과 달리 데이터의 외부 표현을 담당합니다. 예를 들어, 플랫폼 서비스에서 플랫폼 데이터를 외부로 전달할 때 DTO를 사용합니다.
- **레포지토리 패턴 (Repository Pattern)**: 데이터 액세스 로직을 캡슐화하여, 컨트롤러가 데이터베이스와 직접 상호작용하지 않도록 합니다. 인터페이스(`IPlatformRepo`)와 구체 클래스(`PlatformRepo`)로 구성됩니다.
- **API 컨트롤러 (API Controller)**: RESTful API 엔드포인트를 제공하여 클라이언트 요청을 처리합니다. 예를 들어, 플랫폼 데이터를 생성, 조회, 업데이트, 삭제하는 API 엔드포인트를 정의합니다.
- **HTTP 클라이언트 (HTTP Client)**: 다른 서비스와의 동기식 통신을 처리합니다. 예를 들어, 명령 서비스와 통신하여 필요한 데이터를 주고받을 수 있습니다.
- **메시지 퍼블리셔 (Message Publisher)**: 이벤트 버스를 통해 비동기 메시지를 발행하여 다른 서비스에 이벤트를 알립니다. 예를 들어, 새로운 플랫폼이 생성되면 이벤트 버스를 통해 명령 서비스에 알립니다.
- **gRPC 서버 (gRPC Server)**: gRPC를 사용하여 고성능, 저지연의 원격 프로시저 호출을 처리합니다. 플랫폼 서비스가 gRPC 서버로 동작하여 명령 서비스에서 데이터를 요청할 수 있습니다.

### 명령 서비스의 어플리케이션 아키텍처
- **모델**: 명령 서비스의 데이터 구조를 정의합니다. 예를 들어, `Command` 모델 클래스는 명령 인수 데이터를 정의합니다.
- **DB 컨텍스트**: `AppDbContext` 클래스는 Entity Framework를 사용하여 명령 서비스의 데이터베이스와 상호작용합니다.
- **DTO (Data Transfer Objects)**: 명령 데이터를 외부 클라이언트와 교환하기 위한 객체입니다.
- **레포지토리 패턴 (Repository Pattern)**: 데이터 액세스 로직을 캡슐화하여, 컨트롤러가 데이터베이스와 직접 상호작용하지 않도록 합니다.
- **API 컨트롤러 (API Controller)**: 명령 데이터를 생성, 조회, 업데이트, 삭제하는 RESTful API 엔드포인트를 제공합니다.
- **메시지 구독자 (Message Subscriber)**: 이벤트 버스에서 발행된 메시지를 구독하여 처리합니다. 예를 들어, 플랫폼 서비스에서 발행한 새로운 플랫폼 이벤트를 수신하여 데이터베이스에 저장합니다.
- **gRPC 클라이언트 (gRPC Client)**: 플랫폼 서비스와 gRPC를 사용하여 통신합니다. 명령 서비스가 gRPC 클라이언트로 동작하여 플랫폼 서비스에서 데이터를 요청할 수 있습니다.

### 주요 상호작용
- **동기식 통신**: HTTP 클라이언트와 gRPC를 사용하여 두 서비스가 필요할 때 데이터를 직접 요청하고 응답받습니다.
- **비동기식 통신**: 이벤트 버스를 사용하여 서비스 간에 이벤트를 발행하고 구독합니다. 플랫폼 서비스가 새로운 플랫폼 이벤트를 발행하면 명령 서비스가 이를 구독하여 데이터를 처리합니다.

