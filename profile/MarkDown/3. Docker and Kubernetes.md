# 3. 도커와 쿠버네티스
## Docker란 무엇인가?
Docker는 컨테이너화 플랫폼으로, 애플리케이션을 이미지로 패키징하고 이를 컨테이너로 실행할 수 있도록 해줍니다.

Docker를 실행할 수 있는 모든 플랫폼에서 이러한 컨테이너를 실행할 수 있습니다.


### 물리, 가상, 컨테이너 환경 비교

| 환경 유형    | 설명                                                                 | 장점                                                                                  | 단점                                                                             |
|--------------|----------------------------------------------------------------------|---------------------------------------------------------------------------------------|----------------------------------------------------------------------------------|
| 물리 환경    | 실제 하드웨어에서 직접 운영 체제를 설치하고 애플리케이션을 실행하는 환경. | - 고성능 제공<br>- 하드웨어 자원을 완전히 사용 가능                                    | - 유연성 부족<br>- 높은 하드웨어 비용<br>- 스케일링 어려움                       |
| 가상 환경    | 하이퍼바이저를 사용하여 하나의 물리적 서버에서 여러 가상 머신을 실행하는 환경. | - 자원 효율성 향상<br>- 더 나은 유연성<br>- 이식성 증가                                 | - 오버헤드 발생<br>- 성능 저하 가능성<br>- 관리 복잡성 증가                      |
| 컨테이너 환경 | 컨테이너화 기술(Docker 등)을 사용하여 애플리케이션과 그 종속성을 컨테이너로 격리하여 실행하는 환경. | - 가벼운 오버헤드<br>- 빠른 시작 시간<br>- 높은 이식성<br>- 일관된 환경 제공             | - 네트워크 및 스토리지 복잡성<br>- 보안 이슈<br>- 완전한 격리성 부족 가능성       |

### dockerfile
- [Docker에서 .NET 실행](https://learn.microsoft.com/ko-kr/aspnet/core/host-and-deploy/docker/building-net-docker-images?view=aspnetcore-8.0)


- dockerfile
    ```docker
    # FROM -> 이미지 정의
    # AS -> 이름 지정
    # mcr.microsoft.com/dotnet/sdk:8.0 -> .NET sdk 이미지
    FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build-env
    # WORKDIR 작업디렉토리 설정
    WORKDIR /app

    # COPY -> 호스트의 파일을 WORKDIR로 복사
    COPY *.csproj ./
    # RUN -> FROM으로 가져온 이미지의 명령어 실행
    # dotnet restore -> sdk의 명령어. 의존성(*.csproj) 복원
    RUN dotnet restore

    # COPY . ./ -> 모든 파일 복사. 기존 복사와 중복되므로 개선 필요
    COPY . ./
    # dotnet publish -> sdk의 명령어. 프로젝트 빌드, 배포파일 생성
    # -c Release -> --configuration, 빌드 구성을 Release로 설정
    # -o out -> --out, 출력 디렉토리를 작업디렉토리의 out으로 설정
    RUN dotnet publish -c Release -o out

    # mcr.microsoft.com/dotnet/aspnet:8.0 -> 런타임 이미지
    FROM mcr.microsoft.com/dotnet/aspnet:8.0
    # 외부에서 접근할 수 있는 네트워크 포트 지정
    WORKDIR /app
    # .build-env의 이미지를 /app/out으로 복사
    COPY --from=build-env /app/out .
    # ENTRYPOINT -> 컨테이너 실행시 명령어 지정
    # dotnet의 PlatformService.dll 실행
    ENTRYPOINT ["dotnet", "PlatformService.dll"]
    ```

- 도커 버전 확인
    ```powershell
    docker --version
    ```
    Docker version 27.0.3, build 7d4bcd8

- 도커 이미지 빌드하기
    ```powershell
    docker build -t <docker-hub-id>/platformservice .
    ```
    docker desktop으로 빌드된 이미지를 확인할 수 있다.
- 도커 이미지 실행
    ```powershell
    docker run -p 8080:80 -d <docker-hub-id>/platformservice
    ```
    컨테이너를 생성하면 ENTRYPOINT 또는 CMD 명령어가 실행된다.
    
    -p -> --port, 포트번호
    
    -d -> --detached, 컨테이너를 백그라운드에서 실행한다. 터미널을 계속 사용할 수 있다.
- 실행중인 컨테이너 확인
    ```powershell
    docker ps
    ```
- 실행중인 컨테이너 중지
    ```powershell
    docker stop <container-id>
    ```
- 도커허브 로그인
    ```powershell
    docker login
    ```
    만약 Google, GitHub 계정이라면 Dokcer Hub에서 Access Token을 발급받는다.
- 도커허브로 푸쉬하기
    ```powershell
    docker push <docker-hub-id>/platformservice
    ```
    도커허브에서 푸쉬된 이미지를 확인할 수 있다.
- 중지된 컨테이너 시작하기
    ```powershell
    docker start <container-id>
    ```
    중지된 컨테이너를 확인하고 싶다면
    ```powershell
    docker ps -a
    ```
    를 사용할 수 있다.
### HTTP 요청
- GET `http://localhost:8080/api/platforms`
## 쿠버네티스
- 선언적 모델 (Declarative Model)
- 원하는 "최종 상태"를 정의하고, 쿠버네티스가 그 상태에 도달하는 방법을 찾아냅니다.
### 쿠버네티스란 무엇인가?
- 구글이 개발하고 현재는 클라우드 네이티브 재단(Cloud Native Foundation)에서 유지 관리 중
- K8s로 불림
- 컨테이너 오케스트레이션 도구
- 방대한 주제 영역
- 두 가지 주요 사용자 프로파일
  - 개발자(Developer): 애플리케이션을 개발하고 배포하는 역할을 합니다.
  - 관리자(Administrator): Kubernetes 클러스터를 관리하고 유지하는 역할을 합니다.
### 쿠버네티스 아키텍처
- 구성요소
  - 하드웨어(PC)
  - 운영체제(WSL2)
  - 컨테이너 런타임(Docker)
  - 쿠버네티스(Docker Desktop)
    - 클러스터(Cluster): 쿠버네티스의 기본단위, 하나 이상의 노드로 구성
      - 노드(Node): 클러스터 내의 개별 머신, 컨테이너화된 어플리케이션이 실행됨, 하나 이상의 포드로 구성
        - 포드(Pod): 쿠버네티스의 가장 작은 배포단위, 하나 이상의 컨테이너로 구성
          - 컨테이너(Container): 실제 애플리케이션의 실행 단위
    - PVC
  - Network Setting
    - NodePort
    - ClusterIP
    - Ingress Nginx Load Balancer
### PlatformService 배포하기
- 솔루션 폴더에서 `K8S\platforms-depl.yaml`을 만든다.
    ```yaml
    apiVersion: apps/v1
    kind: Deployment
    metadata:
    name: platforms-depl
    spec: 
    replicas: 1
    selector:
        matchLabels:
        app: platformservice
    template:
        metadata:
        labels:
            app: platformservice
        spec:
        containers:
            - name: platformservice
              image: <docker-hub-id>/platformService:latest
    ```
- docker desktop-Setting-Kubernetes에서 Enable Kubernetes를 체크하고 Apply & Restart한다.
- 쿠버네티스 버전확인
    ```powershell
    kubectl version
    ```
- yaml 파일을 쿠버네티스 클러스터에 적용(해당 파일이 있는 위치에서 실행해야함)
    ```powershell
    kubectl apply -f platforms-depl.yaml
    ```
- 쿠버네티스에서 배포된 리소스 조회 
    ```powershell
    kubectl get deployments
    kubectl get pods
    ```
    ready에 1/1이라면 잘 적용된 것이다.
- docker desktop에서 확인
  - k8s_POD: 네트워크 네임스페이스를 유지하기 위한 pause 이미지
  - k8s_platformservice: 실제 애플리케이션
    - log 확인 가능
- 리소스 제거
    ```powershell
    kubectl delete deployment platforms-depl
    ```
- 포드 수 조정
    yaml파일의 replicas의 숫자로 포드의 복제본 수를 조절 가능하다.
### NodePort Service
- 쿠버네티스에서 NodePort 유형의 서비스를 만든다.
- 솔루션 폴더에서 `K8S\platforms-np-srv.yaml`을 만든다.
    ```yaml
    apiVersion: v1
    kind: Service
    metadata:
    name: platformnpservice-srv
    spec:
    type: NodePort
    selector:
        app: platformservice
    ports:
    - name: platformservice
        protocol: TCP
        port: 80
        targetPort: 8080
        nodePort: 30000
    ```
- 고정된 포트(30000~32767 범위)를 열어서 클러스터 내부의 포트로 전달한다.
- 서비스 조회
    ```powershell
    kubectl get services
    ```
- http://localhost:30000/api/platforms 로 요청하여 확인한다.
- 
