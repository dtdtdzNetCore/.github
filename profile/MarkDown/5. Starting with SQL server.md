# 5. SQL 서버 시작하기
## Persistent Volume Claim 추가하기
- Persistent Volume Claim: Persistent Volume Claim(PVC)은 Pod가 요청하는 스토리지 리소스를 추상화한 것입니다.
- 솔루션 폴더에서 `K8S\local-pvc.yaml`을 만든다.
    ```yaml
    apiVersion: v1
    kind: PersistentVolumeClaim
    metadata:
    name: mssql-claim
    spec:
    accessModes:
    - ReadWriteMany
    resources:
        requests:
        storage: 200Mi
    ```
- yaml을 적용하고 확인한다.
    ```powershell
    kubectl apply -f local-pvc.yaml
    kubectl get pvc
    ```
## Kubernetes Secret 추가하기
- secret을 생성한다.
    ```powershell
    kubectl create secret generic mssql --from-literal=SA_PASSWORD="pa55wOrd"
    ```
## SQL 서버 쿠버네티스에 배포하기
- 솔루션 폴더에서 `K8S\mssql-plat-depl.yaml`을 만든다.
    ```yaml
        apiVersion: apps/v1
        kind: Deployment
        metadata:
        name: mssql-depl
        spec:
        replicas: 1
        selector:
            matchLabels:
            app: mssql
        template:
            metadata:
            labels:
                app: mssql
            spec:
            containers:
            - name: mssql
                image: mcr.mivrosoft.com/mssql/server:2017-latest
                ports:
                - containerPort: 1433
                env:
                - name: MSSQL_PID
                  value: "Express"
                - name: ACCEPT_EULA
                value: "Y"
                - name: SA_PASSWORD
                valueFrom:
                    secretKeyRef:
                    name: mssql
                    key: SA_PASSWORD
                volumeMounts:
                - mountPath: /var/opt/mssql/data
                name: mssqldb
            volumes:
            - name: mssqldb
                persistentVolumeClaim:
                claimName: mssql-claim
        ---
        apiVersion: v1
        kind: Service
        metadata:
        name: mssql-clusterip-srv
        spec:
        type: ClusterIP
        selector:
            app: mssql
        ports:
        - name: mssql
            protocol: TCP
            port: 1433
            targetPort: 1433
        ---
        apiVersion: v1
        kind: Service
        metadata:
        name: mssql-loadbalancer
        spec:
        type: LoadBalancer
        selector:
            app: mssql
        ports:
        - protocol: TCP
            port: 1433
            targetPort: 1433
    ```
- `kubectl apply -f mssql-plat-depl.yaml`로 적용한다.

## SQL 서버에 Microsoft SQL Server Management Studio(SSMS)로 연결
- MS SQL, SSMS 가 필요하다.
- SSMS에서 서버이름 `localhost,1433`에 window 인증으로 로그인한다. 인증서가 없다면 암호화는 선택적으로 둔다.
  - 좌측에서 보안 -> 로그인 -> sa의 비밀번호를 `pa55w0rd`로 설정한다. 없다면 새로그인 -> SQL Server 인증으로 만든다.
- SQL 서버 구성관리자 -> SQL Server 서비스 -> SQL Server (MSSQLSERVER)를 다시시작 한다.
- SSMS에서 SQL Server 인증, sa 로 로그인한다.
  - `test`database를 생성하고, SSMS를 종료한다.
  - docker desktop에서 mssql container를 제거한다.
  - 다시 mssql container가 실행되었을때, SSMS에서 `test` db가 남아있는지 확인한다.
  - `test`db를 제거한다.
## 플랫폼서비스를 SQL에 연결
- PlatformService에서 `appsettings.Production.json`에 추가한다. ssl은 사용하지 않는다.
    ```json
    {
        ...
        "ConnectionStrings": {
            "PlatformsConn": "Server=mssql-clusterip-srv,1433;Initial Catalog=platformsdb;User ID=sa;Password=pa55wOrd;Encrypt=false;"
        }
    }
    ```
    - 실제 프로덕션환경에서는 sa를 권장하지 않는다. 비밀번호도 직접 입력하지 않는게 좋다.
- `StartUp.cs`를 수정한다.
    ```csharp
    namespace PlatformService
    {
        public class Startup
        {


            public IConfiguration Configuration { get; }
            private readonly IWebHostEnvironment _env;
            public Startup(IConfiguration configuration, IWebHostEnvironment env)
            {
                Configuration = configuration;
                _env = env;
            }

            public void ConfigureServices(IServiceCollection services)
            {
                if (_env.IsProduction())
                {
                    System.Console.WriteLine("--> Using SqlServer Db");
                    services.AddDbContext<AppDbContext>(opt => 
                        opt.UseSqlServer(Configuration.GetConnectionString("PlatformsConn")));
                }
                else
                {
                    System.Console.WriteLine("--> Using InMem Db");
                    // Register the DbContext with dependency injection
                    services.AddDbContext<AppDbContext>(opt => 
                        opt.UseInMemoryDatabase("InMem"));
                }
            ...
            }
        }
    }
    ```
- `Program.cs`를 수정한다.
    ```csharp
    ...
    var startup = new Startup(builder.Configuration, builder.Environment);
    ...
    ```   
- `dotnet run`으로 "--> Using SqlServer Db"가 적절히 출력되는지 확인한다.
### 마이그레이션 적용
- 마이그레이션이란 데이터베이스 스키마를 변경하고 버전에 따라 관리하는 과정이다.
- `Data\PrepDb.cs`를 수정한다.
    ```csharp
        public static class PrepDb
        {
            public static void PrepPopulation(IApplicationBuilder app, bool isProd)
            {
                    using(var serviceScope = app.ApplicationServices.CreateScope())
                    {
                        SeedData(serviceScope.ServiceProvider.GetService<AppDbContext>(), isProd);
                    }
            }

            private static void SeedData(AppDbContext context, bool isProd)
            {
                if(isProd)
                {
                    System.Console.WriteLine("--> Attempting to apply migrations...");
                    try
                    {
                        context.Database.Migrate();
                    } 
                    catch (Exception ex)
                    {
                        System.Console.WriteLine($"--> Could not rum migrations: {ex.Message}");
                    }
                }
            ...
            }
        }
    ```
- `StartUp.cs`를 수정한다.
    ```csharp
    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
    {
        ...
        PrepDb.PrepPopulation(app, env.IsProduction());
    }
    ```
- dotnet-ef tool로 마이그레이션
    ```powershell
    dotnet tool install --global dotnet-ef 
    dotnet ef migrations add initialmigration
    ```
  - 에러가 발생하는게 정상이다.
- `StartUp.cs`를 수정한다.
    ```csharp
    public void ConfigureServices(IServiceCollection services)
    {
        // if (_env.IsProduction())
        // {
            System.Console.WriteLine("--> Using SqlServer Db");
            services.AddDbContext<AppDbContext>(opt => 
                opt.UseSqlServer(Configuration.GetConnectionString("PlatformsConn")));
        // }
        // else
        // {
        //     System.Console.WriteLine("--> Using InMem Db");
        //     // Register the DbContext with dependency injection
        //     services.AddDbContext<AppDbContext>(opt => 
        //         opt.UseInMemoryDatabase("InMem"));
        // }
        ...
    }

    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
    {
        ...
        ///PrepDb.PrepPopulation(app, env.IsProduction());
    }    
    ```
- `appsettings.Developement.json`을 수정한다.
    ```json
    {
        ...
        "ConnectionStrings": {
            "PlatformsConn": "Server=localhost,1433;Initial Catalog=platformsdb;User ID=sa;Password=pa55wOrd;"
        }
    }
    ```
- `dotnet ef migrations add initialmigration`을 테스트하면 정상 작동한다.
  - 확인 후`StartUp.cs`의 주석을 취소한다.
- docker build, push한다.
- `kubectl rollout restart deployment platforms-depl` 한다.
- kubectl로 pod를 확인하고 SSMS에서 DB 생성을 확인한다.