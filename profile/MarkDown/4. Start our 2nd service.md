# 두번째 서비스 시작하기
.NET Core를 사용하여 명령 서비스를 구축한다.
## 프로젝트 생성 및 의존성 추가
- 프로젝트 생성
    ```powershell
    dotnet new webapi -n CommandService 
    cd CommandService
    code .
    ```
- 의존성 추가
    ```powershell
    dotnet add package AutoMapper.Extensions.Microsoft.DependencyInjection
    dotnet add package Microsoft.EntityFrameworkCore
    dotnet add package Microsoft.EntityFrameworkCore.Design
    dotnet add package Microsoft.EntityFrameworkCore.InMemory
    ```
- `Property\launchSettings.json`
    ```json
    "https": {
        "commandName": "Project",
        "dotnetRunMessages": true,
        "launchBrowser": true,
        "launchUrl": "swagger",
        "applicationUrl": "https://localhost:6001;http://localhost:6000",
        "environmentVariables": {
            "ASPNETCORE_ENVIRONMENT": "Development"
        }
    }
    ```
## Controller-연결 테스트
- `Controllers\PlatformsController`
    ```csharp
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Threading.Tasks;
    using Microsoft.AspNetCore.Mvc;

    namespace CommandsService.Controllers
    {
        [Route("api/c/[controller]")]
        [ApiController]
        public class PlatformsControllers : ControllerBase
        {
            public PlatformsControllers()
            {
                
            }

            [HttpPost]
            public ActionResult TestInboundConnection(){
                Console.WriteLine("--> Inbound POST # Command Service");

                return Ok("Inbound test of form Platforms Controller");
            }
        }
    }
    ```
- `Program.cs`를 변경한다.
    ```csharp
    var builder = WebApplication.CreateBuilder(args);

    // Add services to the container.
    // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle
    builder.Services.AddEndpointsApiExplorer();
    builder.Services.AddSwaggerGen();
    builder.Services.AddControllers();

    var app = builder.Build();

    // Configure the HTTP request pipeline.
    if (app.Environment.IsDevelopment())
    {
        app.UseSwagger();
        app.UseSwaggerUI();
    }

    app.UseHttpsRedirection();
    app.UseAuthentication();
    app.MapControllers();


    app.Run();

    ```
- dotnet run 이후 post요청을 보내 확인한다.
## 동기 & 비동기 메세징
### 동기 메세징
- 요청/응답 주기: 요청은 응답을 기다립니다.
- 요청자와 응답자는 서로를 알아야 합니다.
- Http, gRPC
### HTTP를 C#에서 비동기로 구현하면?
```csharp
[HttpPost]
public async Task<ActionResult<PlatformReadDto>> CreatePlatform(...)
{...}
```
- 메세징관점: 동기적
- 클라이언트: 응답 대기 -> 동기적
- C#: 긴 실행 작업을 기다리지 않습니다.
- 스레드 풀: 스레드를 스레드 풀로 반환하여 재사용 가능합니다.
### 서비스간 동기 메세징
- 서비스끼리 결합하여 의존성을 만듬
- 긴 의존성 체인으로 이어질 수 있다.
## 비동기 메세징
- 요청/응답 주기 없음: 요청자가 응답을 기다리지 않습니다.
- 이벤트 모델: 예시. publish-subscribe 방식
- 주로 서비스간 사용: RabbitMQ, Kafka
- 서비스간 독립성: 서비스는 서로 알 필요없이 메세징 큐(이벤트 버스)만 알면 된다.
## 플랫폼 서비스 - Http clinet 추가
- PlatformService로 다시 돌아간다.
- `SyncDataServices\Http\ICommandDataClient.cs`
    ```csharp
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Threading.Tasks;
    using PlatformService.Dtos;

    namespace PlatformService.SyncDataServices.Http
    {
        public interface ICommandDataClient
        {
            Task SendPlatformToCommand(PlatformReadDto plat);
        }
    }
    ```
- `SyncDataServices\Http\HttpCommandDataClient.cs`
    ```csharp
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using System.Text.Json;
    using System.Threading.Tasks;
    using PlatformService.Dtos;

    namespace PlatformService.SyncDataServices.Http
    {
        public class HttpCommandDataClient : ICommandDataClient
        {
            private readonly HttpClient _httpClient;
            private readonly IConfiguration _configuration;
            public HttpCommandDataClient(HttpClient httpClient,
            IConfiguration configuration)
            {
                _httpClient = httpClient;
                _configuration = configuration;
            }
            public async Task SendPlatformToCommand(PlatformReadDto plat)
            {
                var httpContent = new StringContent(
                    JsonSerializer.Serialize(plat),
                    Encoding.UTF8,
                    "application/json");
                var response = await _httpClient.PostAsync($"{_configuration["CommandService"]}", httpContent);

                if(response.IsSuccessStatusCode)
                {
                    Console.WriteLine("--> Sync POST to CommandService was OK!");
                }
                else
                {
                    Console.WriteLine("--> Sync POST to CommandService was NOT OK!");
                }
            }
        }
    }
    ```
- `appsettings.Development.json`에 추가
    ```json
        {...},
        "CommandService": "http://localhost:6000"
    ```
- `StartUp.cs`에 추가
    ```csharp
    public void ConfigureServices(IServiceCollection services)
    {
        ...
        services.AddHttpClient<ICommandDataClient, HttpCommandDataClient>();

        Console.WriteLine($"--> CommandService EndPoint {Configuration["CommandService"]}");
    }
    ```
- CommandService, PlatformService 둘 다 dotnet run 하고 POST `http://localhost:5000/api/platforms` 요청한다.
  - CommandService에서 "--> Inbound POST # Command Service" 를 확인할 수 있다.
  - CommandService를 중지하고 요청을 보내서 PlatformService에서 "--> Could not send synchronously:..."이 나오는지 확인한다.
## 쿠버네티스에 배포하기
- CommandService의 docker 이미지를 빌드하고 docker hub에 푸쉬한다.
    ```powershell
    docker build -t <docker-hub-id>/commandservice .
    docker push <docker-hub-id>/commandservice
    ```
- platformService에 `appsettings.Production.json`을 만든다.
    ```json
    {
      "CommandService": "http://commands-clusterip-srv:8080/api/c/platforms"
    }
    ```
- platformservice의 docker 이미지를 빌드하고 docker hub에 푸쉬한다.
    ```powershell
    docker build -t <docker-hub-id>/platformservice .
    docker push <docker-hub-id>/platformservice
    ```
- 솔루션 폴더에서 `K8S\commands-depl.yaml`을 만든다.
    ```yaml
    apiVersion: apps/v1
    kind: Deployment
    metadata:
    name: command-depl
    labels:
        app: commandservice
    spec:
    replicas: 1
    selector:
        matchLabels:
        app: commandservice
    template:
        metadata:
        labels:
            app: commandservice
        spec:
        containers:
        - name: commandservice
            image: dtdtdz/commandservice:latest
            ports:
            - containerPort: 8080
    ---
    apiVersion: v1
    kind: Service
    metadata:
    name: commands-clusterip-srv
    spec:
    type: ClusterIP
    selector:
        app: commandservice
    ports:
    - name: commandservice
        protocol: TCP
        port: 8080
        targetport: 8080
    ```
- `K8S\platforms-depl.yaml`에 Service를 추가한다.
    ```yaml
    ...
    ---
    apiVersion: v1
    kind: Service
    metadata:
    name: platforms-clusterip-srv
    spec:
    type: ClusterIP
    selector:
        app: platformservice
    ports:
    - name: platformservice
        protocol: TCP
        port: 8080
        targetPort: 8080
    ```
- kubectl로 yaml를 적용시킨다.
    ```powershell
    kubectl apply -f platform-depl.yaml
    #중단없이 다시시작
    kubectl rollout restart deployment platforms-depl
    kubectl apply -f commands-depl.yaml 
    ```
- platformservice의 log "--> CommandService EndPoint http://commands-clusterip-srv:8080/api/c/platforms"를 확인한다.
- POST요청 "http://localhost:30000/api/platforms"를 보내고 commandservice의 log"--> Inbound POST # Command Service"를 확인한다.
- platformservice의 `StartUp.cs`에서 `app.UseHttpsRedirection()`를 지운다.
## API 게이트웨이 추가하기
- kubernetes ingress: 클러스터 외부에서 내부 서비스로 HTTP 및 HTTPS 트래픽을 라우팅하는 데 사용되는 API 객체입니다.
- [Ingress-nginx github](https://github.com/kubernetes/ingress-nginx)적용
    ```powershell
    kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.11.1/deploy/static/provider/cloud/deploy.yaml
    ```
- Ingress-Nginx 확인
    ```powershell
    kubectl get namespace
    kubectl get pods --namespace=ingress-nginx
    kubectl get services --namespace=ingress-nginx
    ```
- 솔루션 폴더에서 `K8S\ingress-srv.yaml`을 만든다.
    ```yaml
    apiVersion: networking.k8s.io/v1
    kind: Ingress
    metadata:
    name: ingress-srv
    annotations:
        kubernetes.io/ingress.class: nginx
        nginx.ingress.kubernetes.io/use-regex: 'true'
    spec:
    rules:
    - host: acme.com
        http:
        paths:
        - path: /api/platforms
            pathType: Prefix
            backend:
            service:
                name: platforms-clusterip-srv
                port:
                number: 8080
        - path: /api/c/platforms
            pathType: Prefix
            backend:
            service:
                name: commands-clusterip-srv
                port:
                number: 8080
    ```
- vscode의 파일열기로 `C:\Windows\System32\drivers\etc\hosts`파일을 열고 `acme.com`을 추가한다.
    ```
    ...
    127.0.0.1 acme.com
    # Added by Docker Desktop
    ...
    ```
- ingress-srv를 적용한다.
    ```powershell
    kubectl apply -f ingress-srv.yaml   
    ```
- GET `http://acme.com/api/platforms`의 결과를 확인한다.