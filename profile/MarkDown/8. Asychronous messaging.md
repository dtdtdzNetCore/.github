# 8. 비동기 메세징
## 플랫폼 서비스에 메세지 버스 발행자 추가하기
- 플랫폼 서비스로 이동하고 powershell에서 다음을 수행한다.
    ```powershell
    dotnet add package RabbitMQ.Client
    ```
- `appsettings.Development.json`에 추가한다.
    ```json
    {
        ...
        "RabbitMQHost": "localhost",
        "RabbitMQPort": "5672"
    }
    ```
- `appsettings.Production.json`에 추가한다.
    ```json
    {
        ...
        "RabbitMQHost": "rabbitmq-clusterip-srv",
        "RabbitMQPort": "5672"
    }
    ```
- `Dtos\PlatformPublishedDto.cs`
    ```csharp
    namespace PlatformService.Dtos
    {
        public class PlatformPublishedDto
        {
            public int Id { get; set; }
            public string Name { get; set; }
            public string Event { get; set; }   
        }
    }
    ```
- `Profiles\PlatformsProfile.cs`에 추가한다.
    ```csharp
    public PlatformsProfile()
    {
        ...
        CreateMap<PlatformReadDto, PlatformPublishedDto>();
    }
    ```
- `AsyncDataServices\IMessageBusClient.cs`
    ```csharp
    namespace PlatformService.AsyncDataServices
    {
        public interface IMessageBusClient
        {
            void PublishNewPlatform(PlatformPublishedDto platformPublishedDto);
        }
    }
    ```
- `AsyncDataServices\MessageBusClient.cs`
    ```csharp
    namespace PlatformService.AsyncDataServices
    {
        public class MessageBusClient : IMessageBusClient
        {
            private readonly IConfiguration _configuration;
            private readonly IConnection _connection;
            private readonly IModel _channel;

            public MessageBusClient(IConfiguration configuration)
            {
                _configuration = configuration;
                var factory = new ConnectionFactory() { 
                    HostName = _configuration["RabbitMQHost"],
                    Port = int.Parse(_configuration["RabbitMQPort"])};
                    try
                    {
                        _connection = factory.CreateConnection();
                        _channel = _connection.CreateModel();

                        _channel.ExchangeDeclare(exchange: "trigger", type: ExchangeType.Fanout);

                        _connection.ConnectionShutdown += RabbitMQ_CoonnectionShutdown;

                        System.Console.WriteLine("--> Connected to MessageBus");
                    }
                    catch(Exception ex)
                    {
                        System.Console.WriteLine($"--> Could not connect to the Messsage Bus: {ex.Message}");
                    }
            }
            public void PublishNewPlatform(PlatformPublishedDto platformPublishedDto)
            {
                var message = JsonSerializer.Serialize(platformPublishedDto);

                if (_connection.IsOpen)
                {
                    System.Console.WriteLine("--> RabbitMQ Connection Open, sending message...");
                    //To do send the message
                    SendMessage(message);
                }
                else
                {
                    System.Console.WriteLine("--> RabbitMQ connection is closed not, sending");
                }
            }

            private void SendMessage(string message)
            {
                var body = Encoding.UTF8.GetBytes(message);

                _channel.BasicPublish(exchange: "trigger",
                routingKey: "",
                basicProperties: null,
                body: body);
                System.Console.WriteLine($"--> We have sent {message}");
            }

            public void Dispose()
            {
                System.Console.WriteLine("MessageBus Disposed");
                if (_channel.IsOpen)
                {
                    _channel.Close();
                    _connection.Close();
                }
            }

            private void RabbitMQ_CoonnectionShutdown(object sender, ShutdownEventArgs e){
                System.Console.WriteLine("--> RabbitMQ Connection Shutdown");
            }
        }
    }
    ```
- `StartUp.cs`에 추가한다.
    ```csharp
    public void ConfigureServices(IServiceCollection services)
    {
        ...
        services.AddSingleton<IMessageBusClient, MessageBusClient>();
        ...
    }
    ```
- `Controllers\PlatformsController.cs`를 변경한다.
    ```csharp
    namespace PlatformService.Controllers
    {   
        [Route("api/[controller]")]
        [ApiController]
        public class PlatformsController : ControllerBase
        {
            private readonly IPlatformRepo _repository;
            private readonly IMapper _mapper;
            private readonly ICommandDataClient _commandDataClient;
            private readonly IMessageBusClient _messageBusClient;

            public PlatformsController(IPlatformRepo repository,
            IMapper mapper,
            ICommandDataClient commandDataClient,
            IMessageBusClient messageBusClient)
            {
                _repository = repository;
                _mapper = mapper;
                _commandDataClient = commandDataClient;
                _messageBusClient = messageBusClient;
            }

            ...

            [HttpPost]
            public async Task<ActionResult<PlatformReadDto>> CreatePlatform(PlatformCreateDto platformCreateDto)
            {
                var platformModel = _mapper.Map<Platform>(platformCreateDto);
                _repository.CreatePlatform(platformModel);
                _repository.SaveChanges();

                var platformReadDto = _mapper.Map<PlatformReadDto>(platformModel);
                // Send Sync Message
                try
                {
                    await _commandDataClient.SendPlatformToCommand(platformReadDto);
                } 
                catch (Exception ex)
                {
                    System.Console.WriteLine($"--> Could not send synchronously: {ex.Message}");
                }

                //Send Async Message
                try
                {
                    var platformPublishedDto = _mapper.Map<PlatformPublishedDto>(platformReadDto);
                    platformPublishedDto.Event = "Platform_Published";
                    _messageBusClient.PublishNewPlatform(platformPublishedDto);
                }
                catch (Exception ex)
                {
                    System.Console.WriteLine($"--> Could not send asynchronously: {ex.Message}");
                }

                return CreatedAtRoute(nameof(GetPlatformById), new {Id = platformReadDto.Id}, platformReadDto);
            }
        }
    }
    ```
## 메세지 발행자 테스트하기
- 플랫폼 서비스와 명령 서비스에서 `dotnet run`이후 http요청을 보낸다.
  - `http://localhost:5000/api/platforms`를 보내고 플랫폼 서비스의 콘솔 출력을 확인한다.
    - --> Sync POST to CommandService was OK!"
    - --> RabbitMQ Connection Open, sending message...
    - --> We have sent {"Id":4,"Name":"Docker","Event":"Platform_Published"}
  - `localhost:15672`의 guest로 접근한 페이지에서 RabbitMQ의 상태를 모니터링할 수 있다.
## 명령 서비스 준비
- 명령 서비스로 이동하고 powershell에서 다음을 수행한다.
    ```powershell
    dotnet add package RabbitMQ.Client
    ```
- `appsettings.Development.json`에 추가한다.
    ```json
    {
        ...
        "RabbitMQHost": "localhost",
        "RabbitMQPort": "5672"
    }
    ```
- `appsettings.Production.json`에 추가한다.
    ```json
    {
        ...
        "RabbitMQHost": "rabbitmq-clusterip-srv",
        "RabbitMQPort": "5672"
    }
    ```
- `Dtos\PlatformPublishedDto.cs`
    ```csharp
    namespace CommandsService.Dtos
    {
        public class PlatformPublishedDto
        {
            public int Id { get; set; }
            public string Name { get; set; }
            public string Event { get; set; }   
        }
    }
    ```
- `Profiles\PlatformsProfile.cs`에 추가한다.
    ```csharp
    public PlatformsProfile()
    {
        ...
        CreateMap<PlatformPublishedDto, Platform>()
            .ForMember(dest => dest.ExternalId, opt => opt.MapFrom(src => src.Id));
    }
    ```
- `Data\ICommandRepo.cs`에 추가한다.
    ```csharp
    public interface ICommandRepo
    {
        ...
        bool ExteramlPlatformExist(int externalpaltformId);

    }
    ```
- `Data\CommandRepo.cs`에 추가한다.
```csharp
public interface CommandRepo
{
    ...

        public bool ExteramlPlatformExist(int externalpaltformId)
        {
            return _context.Platforms.Any(p => p.ExternalId == externalpaltformId);
        }

}
```
## 이벤트 처리
- `EventProcessing\IEventProcessor.cs`
```csharp
namespace CommandsService.EventProcessing
{
    public interface IEventProcessor
    {
        void ProcessEvent(string message);
    }
}
```
- `EventProcessing\EventProcessor.cs`
    ```csharp
    namespace CommandsService.EventProcessing
    {
        public class EventProcessor : IEventProcessor
        {
            private readonly IServiceScopeFactory _scopeFactory;
            private readonly IMapper _mapper;

            public EventProcessor(IServiceScopeFactory scopeFactory, IMapper mapper)
            {
                _scopeFactory = scopeFactory;
                _mapper = mapper;
            }
            public void ProcessEvent(string message)
            {
                var eventType = DetermineEvent(message);

                switch (eventType)
                {
                    case EventType.PlatformPublished:
                        //TO DO
                        break;
                    default:
                        break;
                }
            }

            private EventType DetermineEvent(string notificationMessage)
            {
                System.Console.WriteLine("--> Determining Event");

                var eventType = JsonSerializer.Deserialize<GenericEventDto>(notificationMessage);
                
                switch(eventType.Event)
                {
                    case "Platform_Published":
                        System.Console.WriteLine("Platfrom Published Event Detected");
                        return EventType.PlatformPublished;
                    default:
                    System.Console.WriteLine("--> Could noit determine the event type");
                    return EventType.Undeterminded;
                }
            }

            private void addPlatform(string platformPublishedMessage)
            {
                using (var scope = _scopeFactory.CreateScope())
                {
                    var repo = scope. ServiceProvider.GetRequiredService<ICommandRepo>();

                    var platformPublishedDto = JsonSerializer.Deserialize<PlatformPublishedDto>(platformPublishedMessage);

                    try
                    {
                        var plat = _mapper.Map<Platform>(platformPublishedDto);
                        if (!repo.ExteramlPlatformExist(plat.ExternalId))
                        {
                            repo.CreatePlatform(plat);
                            repo.SaveChange();
                        }
                        else
                        {
                            System.Console.WriteLine("--> Platform already exisits...");
                        }
                    }
                    catch (Exception ex)
                    {
                        System.Console.WriteLine($"--> Could not add platform to DB {ex.Message}");
                    }
                }
            }
        }
        
        enum EventType
        {
            PlatformPublished,
            Undeterminded
        }
    }
    ```
- `program.cs`에 추가한다.
    ```csharp
    builder.Services.AddSingleton<IEventProcessor, EventProcessor>();
    ```
## 이벤트 리스너 추가하기
- `AsyncDataService\MessageBusSubscriber.cs`
    ```csharp
    namespace CommandsService.AsyncDataService
    {
        public class MessageBusSubscriber : BackgroundService
        {
            private readonly IConfiguration _configuration;
            private readonly IEventProcessor _eventProcessor;
            private IConnection _connection;
            private IModel _channel;
            private string _queueName;

            public MessageBusSubscriber(
                IConfiguration configuration, 
                IEventProcessor eventProcessor)
            {
                _configuration = configuration;
                _eventProcessor = eventProcessor;

                initializeRabbitMQ();
                
            }
            private void initializeRabbitMQ()
            {
                var factory = new ConnectionFactory() { HostName = _configuration["RabbitMQHost"], Port = int.Parse(_configuration["RabbitMQPort"])};

                _connection = factory.CreateConnection();
                _channel = _connection.CreateModel();
                _channel.ExchangeDeclare(exchange: "trigger", type: ExchangeType.Fanout);
                _queueName = _channel.QueueDeclare().QueueName;
                _channel.QueueBind(queue: _queueName,
                    exchange: "trigger",
                    routingKey: "");

                System.Console.WriteLine("--> Listening on the Message Bus...");
                _connection.ConnectionShutdown += RabbitMQ_ConnectionShutdown;
            }
            protected override Task ExecuteAsync(CancellationToken stoppingToken)
            {
                stoppingToken.ThrowIfCancellationRequested();

                var consumer = new EventingBasicConsumer(_channel);

                consumer.Received += (ModuleHandle, ea) =>
                {
                    System.Console.WriteLine("--> Event Received!");

                    var body = ea.Body;
                    var notificationMessage = Encoding.UTF8.GetString(body.ToArray());

                    _eventProcessor.ProcessEvent(notificationMessage);
                };

                _channel.BasicConsume(queue: _queueName, autoAck: true, consumer: consumer);

                return Task.CompletedTask;
            }
            private void RabbitMQ_ConnectionShutdown(object sender, ShutdownEventArgs e)
            {
                System.Console.WriteLine("--> Connection Shutdown");
            }

            public override void Dispose()
            {
                if (_channel.IsOpen)
                {
                    _channel.Close();
                    _connection.Close();
                }
                base.Dispose();
            }
        }
    }
    ```
- `program.cs`에 추가한다.
    ```csharp
    builder.Services.AddHostedService<MessageBusSubscriber>();
    ```
## 로컬에서 테스트하기
- 플랫폼 서비스와 명령 서비스에서 `dotnet run`이후 http요청을 보낸다.
  - POST`http://localhost:5000/api/platforms`를 보내고 명령 서비스의 콘솔 출력을 확인한다.
    - --> Event Received!
    - --> Determining Event
    - Platfrom Published Event Detected

- `EventProcessing\EventProcessor.cs`를 변경한다.
    ```csharp
    public void ProcessEvent(string message)
    {
        var eventType = DetermineEvent(message);

        switch (eventType)
        {
            case EventType.PlatformPublished:
                addPlatform(message);
                break;
            default:
                break;
        }
    }
    ...
    private void addPlatform(string platformPublishedMessage)
    {
        using (var scope = _scopeFactory.CreateScope())
        {
            var repo = scope. ServiceProvider.GetRequiredService<ICommandRepo>();

            var platformPublishedDto = JsonSerializer.Deserialize<PlatformPublishedDto>(platformPublishedMessage);

            try
            {
                var plat = _mapper.Map<Platform>(platformPublishedDto);
                if (!repo.ExteramlPlatformExist(plat.ExternalId))
                {
                    repo.CreatePlatform(plat);
                    repo.SaveChange();
                    System.Console.WriteLine("--> Platform added!");
                }
                else
                {
                    System.Console.WriteLine("--> Platform already exisits...");
                }
            }
            catch (Exception ex)
            {
                System.Console.WriteLine($"--> Could not add platform to DB {ex.Message}");
            }
        }
    }
    ```
- 플랫폼 서비스와 명령 서비스를 다시 `dotnet run` 한다. 
  - POST `http://localhost:5000/api/platforms`요청시 콘솔에서 "--> Platform added!" 를 확인할 수 있다.
  - POST `http://localhost:6000/api/c/platforms/4/commands`을 다음 JSON body로 요청한다.
    ```JSON
    {
        "HowTo" : "push a docker container",
        "CommandLine" : "docker push <name of container>"
    }
    ```
  - GET `http://localhost:6000/api/c/platforms/4/commands`으로 확인한다.
  - GET `http://localhost:6000/api/c/platforms/4/commands/1`으로 확인한다.
## 쿠버네티스에 배포하기
- 플랫폼 서비스와 명령 서비스를 docker build, push 한다.
- platforms-depl과 commands-depl을 rollout restart 한다.
    ```powershell
    kubelctl rollout restart deployment platforms-depl
    kubelctl rollout restart deployment commands-depl
    ```
- POST `http://acme.com/api/platforms`을 다음 JSON body로 요청한다.
    ```JSON
    {
        "name": "Consul",
        "publisher": "Hashicrop",
        "cost": "Free"
    }
    ```
- `localhost:15672`에서 auto ack 를 확인할 수 있다.
- 명령 서비스의 다른 요청도 테스트해본다.